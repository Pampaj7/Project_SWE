\documentclass{article}
\usepackage{amsfonts, amsmath, amsthm, amssymb}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{needspace}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{color}
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{10pt}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{darkOrange}{rgb}{0.8,0.4, 0.0}
\lstset{frame=tb,
  language=Java,
  aboveskip=5mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{darkOrange},
  commentstyle=\color{mauve},
  stringstyle=\color{dkgreen},
  breaklines=true,
  breakatwhitespace=true,
  basicstyle=\ttm\linespread{0.6}\selectfont,
  tabsize=3
}



\graphicspath{ {Img/}}
\title{Dentist management system}
\author{Leonardo Pampaloni, Filippo di Martino}
\date{September 2022}

\begin{document}
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
        \Huge
        \textbf{Dentist management system}
        
        \vspace{0.5cm}
        \LARGE
        Ingegneria del software
        
        \vspace{1.5cm}
        \textbf{Leonardo Pampaloni, Filippo di Martino}
        \vfill
        \vspace{0.8cm}
        \includegraphics[width=0.4\textwidth]{Img/university}
        \Large
        
        Computer Engineering\\
        University Of Florence\\
        Italy\\
    \end{center}
\end{titlepage}

\tableofcontents
\newpage

\section{Introduzione}
L'idea del progetto nasce come applicazione per la gestione di interventi fatti da dentisti e assistenti su vari clienti. Nell'applicazione sono presenti principalmente:

\begin{enumerate} 
	\item \textbf{\textsl{Dentista}}: 
			Il dentista ha la possibilità di controllare tutte le informazioni riguardanti i clienti, gli assistenti e i set di interventi 					assegnati agli assistenti.
	\item \textbf{\textsl{Assistenti}}:
			Ogni assistente ha a sua disposizione un set predefinito di operazioni da poter fare, oltre che poter vedere le informazioni sui clienti.
	\item \textbf{\textsl{Clienti}}
	\item \textbf{\textsl{Operazioni}}
\end{enumerate}
L'applicazione ha come obiettivo quello di gestire e notificare l'admin, ovvero il dentista, di tutte le operazioni effettuate dagli assistenti, inoltre è compresa nell'applicazione il salvataggio dei clienti, degli articoli e delle operazioni all'interno di un database. Sono presenti due tipologie di notifica per l'admin, uno all'interno dell'applicazione, che tiene traccia dello storico delle operazioni fatte da tutti gli assistenti mentre l'altro è esterno all'applicazione e viene notificato l'admin tramite email ogni volta che un assistente effettua un intervento su un cliente.

\section{Diagrammi UML}
Abbiamo scelto di presentare tre diversi diagrammi UML, il diagramma delle classi (\textsl{Class Diagram}), il diagramma dei casi d'uso (\textsl{Use Case Diagram}), e il diagramma E/R (\textsl{Entity Relationship}) del progetto.


\subsection{Class Diagram}

Dal \textsl{Class Diagram} possiamo vedere come effettivamente sono legate le varie classi del programma. Si può notare infatti che le operazioni di notifica sono effettuate da un \textsl{Observer pattern}, suddiviso in due diverse classi per le due tipologie differenti di notifica. Sono presenti anche altri due pattern: lo \textsl{State pattern} e il \textsl{Composite pattern}, rispettivamente per la gestione delle classi dei vari menù e per la gestione delle classi per le operazioni/interventi.\newline
Il Dentista (\textsl{Admin}) ha il compito di creare Clienti, Articoli, e set di Operazioni/Interventi. Per le operazioni abbiamo incluso la possibilità di raccogliere più interventi in uno (creandolo tramite il \textsl{Composite pattern}), oltre ovviamente a poter selezionare l'uso di più articoli e strumenti (E.g. Creazione di un kit-monouso (Guanti,Bicchiere,Tovaglietta), e includerlo in tutte le operazioni).\newline
La classe \textsl{Program} è il cuore della gestione dell'applicazione: rappresenta il nodo centrale del sistema. \textsl{Program} è una classe \textsl{\textbf{Singleone}} in quanto si necessita di avere una singola istanza di essa e deve essere necessariamente reperibile, al suo interno sono presenti inoltre metodi come \textsl{load(Connection c)} e \textsl{upload(Connection c)} che permettono la comunicazione con il DB esterno e \textsl{run()} per poter gestire il loop di sistema.
\newline

\begin{figure}[h]
\centerline{\includegraphics[scale=.14]{UMLSWE}}
\caption{Diagramma delle classi}
\end{figure}



\subsubsection{State Pattern}
Si tratta di un pattern comportamentale basato su oggetti che viene utilizzato quando il comportamento di un oggetto deve cambiare in base al suo stato. Questo pattern è spesso utilizzato per le macchine a stati finiti, il nostro caso è molto simile a quello scenario, infatti il menù passa da uno stato all'altro in base alla scelta dell'utente che lo sta utilizzando.

\begin{figure}[h]
\centerline{\includegraphics[scale=.35]{StatePattern}}
\caption{Diagramma delle classi (State pattern)}
\end{figure}


\subsubsection{Observer Pattern}
Questo pattern permette di definire una dipendenza 1$\longrightarrow$N fra oggetti, il suo compito è quello di notificare gli N oggetti ogni volta che un oggetto (Subject) cambia stato. Nel progetto sono inseriti due tipologie di Observer: uno che notifica internamente all'applicazione (\textsl{NotificationCenter}) mentre l'altro che manda una mail all'assistente desiderato e all'Admin (\textsl{NotificationEmail}).

\begin{figure}[h]
\centerline{\includegraphics[scale=.365]{ObserverPattern}}
\caption{Diagramma delle classi (Observer pattern)}
\end{figure}


\subsubsection{Composite Pattern}
Il pattern serve per poter trattare un gruppo di oggetti come istanza di un oggetto singolo. Solitamente questo raggruppamento si può vedere come una struttura ad albero, nel progetto però il pattern è stato leggermente modificato per permettere l'annidamento delle classi composte, in questo caso infatti il grafico del pattern potrebbe essere riassunto con un grafo invece di un albero.

\begin{figure}[h]
\centerline{\includegraphics[scale=.45]{CompositePattern}}
\caption{Diagramma delle classi (Composite pattern)}
\end{figure}



\subsection{Use Case Diagram}
Nello \textsl{Use Case Diagram} sono presenti due attori che interagiscono con il sistema, il Dentista e l'Assistente. I due attori hanno un caso d'uso comune, in quanto entrambi sono classi derivate di User.\newline
Di seguito lo Use Case completo del progetto.

\begin{figure}[h]
\centerline{\includegraphics[scale=.3]{UseCaseDiagram}}
\caption{Diagramma dei casi d'uso}
\end{figure}


\newpage
\subsubsection{Dentist's Use Case}
Si distinguono quattro macro gruppi di casi d'uso:
\begin{enumerate} 
	\item \textbf{\textsl{Articoli}}: 
			Il Dentista ha la possibilità di gestire gli articoli, può infatti scegliere se creare, eliminare o semplicemente visualizzare gli Articoli.
	\item \textbf{\textsl{Inventari}}:
			Solo il Dentista ha la possibilità di aggiungere e rimuovere eventuali Inventari contenenti i Set di Operazioni assegnati ai vari 						assistenti.
	\item \textbf{\textsl{Assistenti}}:
			Il Dentista ha la possibilità di gestire anche gli Assistenti, può infatti scegliere se aggiungere, eliminare o visualizzare gli Inventari 					dei vari Assistenti.
	\item \textbf{\textsl{Clienti}}:
			Il Dentista ha la possibilità di gestire i Clienti, può infatti creare, eliminare o visualizzare lo storico delle operazioni avvenute su quel 			Cliente.
\end{enumerate}

\begin{figure}[h]
\centerline{\includegraphics[scale=.4]{OwnerUseCaseDiagram}}
\caption{Diagramma dei casi d'uso del Dentista}
\end{figure}

\newpage
\subsubsection{Assistent's Use Case}
Nello \textsl{Use Case Diagram} dell'Assistente invece sono presenti meno funzionalità, questo perchè è nostro intento dare maggior controllo all'admin del sistema, mentre un controllo limitato ai vari assistenti che hanno accesso al programma. Di seguito le seguenti funzionalità:
\begin{enumerate} 
	\item \textbf{\textsl{Operazioni}}: 
			Tramite la creazione di una nuova operazione è possibile creare o selezionare il cliente alla quale verrà fatto l'intervento. Inoltre è 			possibile vedere lo storico delle operazioni fatte dall'Assistente stesso.
	\item \textbf{\textsl{Inventario}}:
			L'Assistente può vedere quali operazioni ha nel suo inventario.
\end{enumerate}


\begin{figure}[h]
\centerline{\includegraphics[scale=.5]{AssistentUseCaseDiagram}}
\caption{Diagramma dei casi d'uso dell'Assistente}
\end{figure}

\subsection{E/R Diagram}
Per avere più chiarezza su come è strutturato il DB abbiamo fatto il diagramma \textsl{Entity Relationship} della struttura dati.

\begin{figure}[h]
\centerline{\includegraphics[scale=.5]{DiagramER}}
\caption{Diagramma E/R della struttura dati}
\end{figure}

\newpage
\subsubsection{Compound DB Structure}
Di seguito riportiamo una scelta implementativa all'interno del database a nostro dire: 'interessante'. Durante la creazione della logica della struttura dati dovevamo creare un modo per archiviare gli articoli di tipo compound. Essendo questi degli articoli composti da articoli che potevano essere aggiunti ai vari inventari dovevamo travare un modo di creare una composizione all'interno del database. Come possiamo notare la tabella article è composta da un id, un nome e un prezzo.
\begin{figure}[h]
\centerline{\includegraphics[scale=.45]{DBArticle}}
\caption{Struttura Article}
\end{figure}
\newpage
La tabella ArticleCompound è composta da un idCoumpound e un idComponent. Facendo si che entrambe le colonne siano chiave primaria possiamo 'duplicare' i vari idCompound e associarvi diversi idComponent. Questo stratagemma conclude con l'associazione di vari articoli ad un articolo indipendente.

\begin{figure}[h]
\centerline{\includegraphics[scale=.45]{DBArticleCompound}}
\caption{Struttura ArticleCompound}
\end{figure}

\newpage
\section{Implementazione e approfondimento}
Di seguito riportiamo alcuni dei più importanti metodi utilizzati che necessitano di una spiegazione più approfondita.

\subsection{Observer}

Il pattern Observer è utilizzato per notificare sia il dentista che i vari assistenti. Il nostro intento era di fornire all'assistente un resoconto dell'operazione con i vari articoli utilizzati e l'importo dei materiali. Per il dentista invece funge da 'allarme' non appena un assistente dichiara di aver utilizzato alcuni articoli. Più nello specifico il nostro subject non è altro che l'assistente in quanto è responsabile di effettuare le operazioni. Durante il login gli observer sono legati con il metodo \textit{attach()} e al momento del logout viene chiamato il metodo \textit{detach()}. Il pattern observer è implementato attraverso due interfacce ovvero il NotificationEmail e il NotificationCenter. La prima è responsabile di inviare una mail ai diretti interessati col resoconto delle operazioni. L'altra invece è responsabile di notificare il dentista alla sua entrata con le operazioni effettuate in sua assenza.
\UseRawInputEncoding
\begin{lstlisting}[caption={Observer},captionpos=b]
public final class NotificationCenter implements Observer {

    private ArrayList<String> notification;

 @Override
    public void update(Object obj) {
        Operation operation = (Operation)obj;
        this.notification.add("Una nuova operazione per " + operation.getCustomer().getBusinessName() + " è stata fatta da " + operation.getAssistant().getName());
    }

}
\end{lstlisting}


\begin{figure}[h!]
\centerline{\includegraphics[scale=.55]{MenuNotificaDentista}}
\caption{Notifica per il dentista all'interno del programma}
\end{figure}

\subsubsection{Email Observer}
\UseRawInputEncoding
\begin{lstlisting}[caption={Email Observer},captionpos=b]
public final class NotificationEmail implements Observer {

    @Override
    public void update(Object obj) {
        Operation o = (Operation) obj;
        String to = "";
        for (User u : Program.getInstance().getUsers()) {
            if (u instanceof Dentist)
                to += u.getEmail() + ",";
        }
        to = to.substring(0, to.length() - 1); 

        String products = "";
        for (Pair<Article, Integer> a : o.getRows()) {
            products += "--" + a.getValue0().getName() + " qta: " + a.getValue1() + " <br>"; 
        }

        String text;
        text = " ... ";

private void sendEmail(String to, String obj, String text) {

        String test = "pippodima99@gmail.com";
        String from = "ing.software.dimpa@gmail.com";

        Properties properties = System.getProperties();
        properties.put("mail.smtp.host", "smtp.gmail.com");
        properties.put("mail.smtp.port", "465");
        properties.put("mail.smtp.ssl.enable", "true");
        properties.put("mail.smtp.auth", "true");

        Session session = Session.getInstance(properties, new javax.mail.Authenticator() {
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication("ing.software.dimpa@gmail.com", "rkqvtlxwtcaczfjj\n"); 

            }
        });

        session.setDebug(true);

        try {
            MimeMessage message = new MimeMessage(session);

            message.setFrom(new InternetAddress(from));
            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));
            message.setSubject(obj);
            message.setContent(text, "text/html");

            System.out.println("sending...");
            Transport.send(message);
            System.out.println("inviato");

        } catch (MessagingException mex) {
            mex.printStackTrace();
        }
    }

}
\end{lstlisting}
Una volta che il sistema registra le nuove operazioni queste sono le email inoltrate automaticamente dal sistema.

\begin{figure}[h!]
\centering
\begin{subfigure}{.5\textwidth}
\centering
\centerline{\includegraphics[scale=.15]{EmailPerAssist}}
\caption{Email inoltrata all'assistente.}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
\centering
\centerline{\includegraphics[scale=.15]{EmailPerDentista}}
\caption{Email inoltrata al dentista.}
\end{subfigure}
\end{figure}

\subsubsection{Cursiosita'}

Durante le numerose prove di testing per il funzionamento del sistema di notifica e-mail, siamo andati incontro a un imprevisto. Avendo disattivato tutte le possibili protezioni sull'account per poterci accedere dall'applicazione, pensiamo che il fatto di aver fatto tante prove in poco tempo abbia "attirato l'attenzione" di persone di terze parti che sono entrati nell'account o hanno fatto entrare l'indirizzo email in loop di promozioni  e spam vari. Ce ne siamo accorti quando nel lanciare il metodo per mandare l'email, nel terminale era notificato un errore per aver "finito" le mail giornaliere da poter mandare. Una volta andati sul nostro indirizzo email abbiamo visto che sono state inviate c.a. 300 mail in un minuto, con un testo scritto in arabo a proposito di un costo di spedizione per qualche ordine. Ancora oggi non sappiamo cosa sia successo ma ci faceva piacere condividere questa strana esperienza che ci è capitata.\newline
Di seguito un esempio delle tante mail arrivate:

\begin{figure}[h!]
\centerline{\includegraphics[scale=.15]{SiamoStatiHackerati}}
\caption{Email hackerate.}
\end{figure}



\newpage

\subsection{User}
La classe User  \'{e} dichiarata astratta in modo che possa fornire una base di partenza per tutti i tipi di utenti previsti e non, nel nostro programma. La classe astratta presenta metodi base come il \textit{viewOperations()} e il \textit{viewInventory()} che sono comuni alle classi derivate di utente (\textit{Assistente} e \textit{Dentista}).
Questi due metodi sono implementati per\'{o} in due modi diversi in quanto un assistente può visualizzare le operazioni fatte soltanto da se stesso e non quelle degli altri. Il dentista invece \'{e} in grado di vedere tutte le operazioni in quanto \'{e} '\textit{Admin}' del sistema. La classe User possiede inoltre un attributo comune quale la password in quanto ogni utente per loggare nel programma avr\'{a} bisogno delle sue credenziali d'accesso.

\subsubsection{Assistant}
Come in un vero studio dentistico gli assistenti sono in grado di effettuare le proprie operazioni supervisionati dal dentista. Sono in grado di aggiungere i clienti, effettuare le operazioni all'interno dell'inventario a loro associato. Sono inoltre in grado di eliminare clienti nel caso in cui questi vogliano cambiare studio dentistico. Quando gli assistenti effettuano un'operazione l'observer notifica attraverso il sistema di mail sia lui stesso con il resoconto degli articoli utilizzati sia il dentista.


\begin{figure}[h!]
\centerline{\includegraphics[scale=.5]{OperazioneTipoAssistente}}
\caption{Esempio operazione assistente}
\end{figure}



\UseRawInputEncoding
\begin{lstlisting}[caption={Crezione operazione},captionpos=b]
 public void createOperation(Customer c, ArrayList<Pair<Article,Integer>> articles) {
        Operation operation = new Operation(this,articles,c);
        Program.getInstance().getOperations().add(operation);
        System.out.println("Creato!");
        notify(new Operation(operation));
    }
\end{lstlisting}


\UseRawInputEncoding
\begin{lstlisting}[caption={Notify},captionpos=b]
  public void notify(Object obj) {
        for(Observer o: observers)
            o.update(obj);
    }

\end{lstlisting}

\subsubsection{Dentist}
Il dentista, ovvero l'Admin del sistema \'{e} in grado di visualizzare tutte le informazioni di tutte le classi. \'{E} inoltre il responsabile della creazione di nuovi inventari, aggiunta di articoli e articoli composti. Pu\'{o} inoltre cancellare qualsiasi elemento del sistema, persino gli assistenti. Quando assume un nuovo assistente deve associare una mail esistente in modo che il sistema di notifica possa funzionare correttamente.


\UseRawInputEncoding
\begin{lstlisting}[caption={Crezione assistente},captionpos=b]
  public void createAssistant(String name, String password, float commission, Inventory inventory, String email) {
        Program.getInstance().getUsers().add(new Assistant(name,password,commission, inventory,email));
        System.out.println("Creato!");
    }
\end{lstlisting}

Come vediamo nel seguente esempio pu\'{o} vedere tutte le operazioni di uno specifico cliente.

\UseRawInputEncoding
\begin{lstlisting}[caption={Controllo operazioni di un cliente specifico},captionpos=b]
public void viewCustomerOperations(int idCustomer){

        System.out.println("----------------------------------");
        boolean check = false;
        for(Operation i : Program.getInstance().getOperations()){
            if (i.getAssistant()!=null&&i.getAssistant().getId()==idCustomer) {
                System.out.println("Operazione -> ID: " + i.getId() + " TOTALE: " + i.getTotal() + "€ COSTO PERSONALE: " + i.getOPersonalCost() + "€ CLIENTE: " + i.getCustomer().getBusinessName());
                i.printArticle();
                check = true;
            }
        }
        if(!check)
            System.out.println("Non ci sono ordini!.");
        System.out.println("----------------------------------");

    }
\end{lstlisting}


\UseRawInputEncoding
\begin{lstlisting}[caption={Eliminazione di un assistente},captionpos=b]
  public void deleteAssistant(int idAgent){
        Assistant assistant =null;
        for(User i : Program.getInstance().getUsers()){
            if (i instanceof Assistant && i.getId()==idAgent){
                assistant = (Assistant) i;
                break;
            }
        }
\end{lstlisting}

Durante l'eliminazione di un relativo inventario ci siamo trovati davanti ad una difficile scelta implementativa. La problematica era che eliminando un inventario si eliminava pure lo storico delle operazioni di un assistente che ha attinto a quei vari articoli. Inizialmente avevamo creato dei controlli affinch\'{e} non si potesse eliminare un inventario se un assistente avesse usato delle componenti proprie. Successivamente per\'{o}, anche da un confronto con la realt\'{a}, abbiamo deciso di ignorare il problema perch\'{e} se scegliamo di eliminare un determinato inventario \'{e} perch\'{e} decidiamo di effettuare una ristrutturazione della gestione delle risorse in quanto possono cambiare prezzi e disponibilit\'{a}.

\UseRawInputEncoding
\begin{lstlisting}[caption={Eliminazione di un inventario},captionpos=b]
 public void deleteInventory(int IdCatalog){
        Inventory tmp = null;



        for(Inventory i: Program.getInstance().getInventories()){
            if(i.getId()==IdCatalog){
                tmp = i;
            }
        }

        if (tmp == null){
            System.err.println("ID sbagliato! Riprovare");
            return;
        }

        Program.getInstance().getInventories().remove(tmp);
        System.out.println("Cancellato!");
    }
\end{lstlisting}


\subsection{Program}
La classe Program \'{e} responsabile del download e upload dei dati attraverso la funzione \textit{load(Connection c)}, i dati vengono recuperati attraverso delle query al database indicato nella connection e caricati allìinterno degli ArrayList della classe. Durante questa fase di sviluppo, StackOverflow si \'{e} rivelato il nostro migliore amico.


\UseRawInputEncoding
\begin{lstlisting}[caption={Implementazione Load},captionpos=b]
public void load(Connection c) throws SQLException {

        Statement stmt = c.createStatement();
        Statement stmt1 = c.createStatement();
        ResultSet rs, rs1;

        rs = stmt.executeQuery("SELECT * FROM Customer;");
        while (rs.next()) {
            int id = rs.getInt("id");
            String businessName = rs.getString("BusinessName");
            String country = rs.getString("Country");
            String email = rs.getString("Email");
            customers.add(new Customer(id, businessName, country, email));
        }

        rs = stmt.executeQuery("SELECT * FROM Notification;");
        while (rs.next()) {
            String message = rs.getString("message");
            notCenter.addNotification(message);
        }

        rs = stmt.executeQuery("SELECT * FROM Article WHERE id not in (SELECT IdCompound FROM ArticleCompound );");
        while (rs.next()) {
            int id = rs.getInt("id");
            String name = rs.getString("name");
            float price = rs.getFloat("Price");
            articles.add(new Product(name, price, id));
        }
        rs = stmt.executeQuery("SELECT * FROM Article WHERE id in (SELECT IdCompound FROM ArticleCompound );");
        while (rs.next()) {
            int id = rs.getInt("id");
            String name = rs.getString("name");
            ArrayList<Article> components = new ArrayList<>();
            rs1 = stmt1.executeQuery("SELECT * FROM ArticleCompound WHERE IdCompound = " + id + " ;");
            while (rs1.next()) {
                int idComponent = rs1.getInt("idComponent");

                for (Article a : articles) {
                    if (a.getId() == idComponent) {
                        components.add(a);
                        break;
                    }
                }
            }
            articles.add(new Compound(name, components, id));
        }

        rs = stmt.executeQuery("SELECT * FROM InventoryUser;");
        while (rs.next()) {
            int id = rs.getInt("idHead");
            String description = rs.getString("Description");
            String marketZone = rs.getString("MarketZone");
            ArrayList<Article> tmp = new ArrayList<>();
            rs1 = stmt1.executeQuery("SELECT * FROM InventoryArticle WHERE IdHead = " + id + " ;");
            while (rs1.next()) {
                int idArticle = rs1.getInt("idArticle");
                for (Article a : articles) {
                    if (a.getId() == idArticle) {
                        tmp.add(a);
                        break;
                    }
                }
            }
            inventories.add(new Inventory(tmp, description, marketZone, id));
        }

        rs = stmt.executeQuery("SELECT * FROM User;");
        while (rs.next()) {
            int id = rs.getInt("id");                             //1 agent - 0 administrator
            String name = rs.getString("Name");
            String passHash = rs.getString("Password");
            int type = rs.getInt("Type");
            int idInventory = rs.getInt("IdInventory");
            float personalCost = rs.getFloat("PersonalCost");
            String email = rs.getString("email");

            if (type == 1) {
                Inventory tmp = null;
                for (Inventory i : inventories) {
                    if (i.getId() == idInventory) {
                        tmp = i;
                    }
                }

                if (tmp == null) {
                    System.err.println("Inventory don't exist!");
                    break;
                }

                users.add(new Assistant(name, passHash, personalCost, tmp, email, id));
            } else {
                users.add(new Dentist(name, passHash, email, id));
            }
        }

        rs = stmt.executeQuery("SELECT * FROM CustomerAssistant;");
        while (rs.next()) {
            int id = rs.getInt("idHead");
            int Assistant = rs.getInt("idAssistant");
            int idCustomers = rs.getInt("IdCustomer");
            float total = rs.getFloat("Total");
            float cost = rs.getFloat("PersonalCost");

            Assistant tmpAssistant = null;
            for (User i : users) {
                if (i.getId() == Assistant) {
                    tmpAssistant = (Assistant) i;
                    break;
                }
            }

            Customer tmpCustomer = null;
            for (Customer i : customers) {
                if (i.getId() == idCustomers) {
                    tmpCustomer = i;
                    break;
                }
            }

            if (tmpCustomer == null) {
                System.err.println("Customer don't exist!");
                break;
            }

            ArrayList<Pair<Article, Integer>> tmp = new ArrayList<>();
            rs1 = stmt1.executeQuery("SELECT * FROM CustomerAssistantArticle WHERE IdHead = " + id + " ;");
            while (rs1.next()) {
                int idArticle = rs1.getInt("idArticle");
                int qta = rs1.getInt("qta");
                for (Article a : articles) {
                    if (a.getId() == idArticle) {
                        tmp.add(new Pair<>(a, qta));
                        break;
                    }
                }
            }
            operations.add(new Operation(total, cost, tmpAssistant, tmp, tmpCustomer, id));
        }

    }

\end{lstlisting}

Analogamente abbiamo la parte che consente l'operazione opposta che elimina tutte le entry nel DB e inserisce le nuove tuple.

\UseRawInputEncoding
\begin{lstlisting}[caption={Implementazione Upload},captionpos=b]
public void upload(Connection c) {
        String sql;
        Statement stmt = null;
        try {
            stmt = c.createStatement();
            for (String s : Arrays.asList("DELETE FROM User;", "DELETE FROM CustomerAssistant;", "DELETE FROM CustomerAssistantArticle;", "DELETE FROM Notification;", "DELETE FROM Customer;", "DELETE FROM InventoryArticle;", "DELETE FROM InventoryUser;", "DELETE FROM Article;", "DELETE FROM ArticleCompound;")) {
                sql = s;
                stmt.executeUpdate(sql);
                c.commit();
            }
        } catch (Exception e) {
            System.err.println(e.getClass().getName() + ": " + e.getMessage());
            System.exit(0);
        }

        int type;
        float perch;
        for (User user : users) {
            try {
                if (!(user instanceof Assistant)) {
                    type = 0;
                    perch = 0;
                    sql = "INSERT INTO User (Id,Name,Password,Type,PersonalCost,email) " + "VALUES (" + user.getId() + ", '" + user.getName() + "', '" + user.getPassword() + "', " + type + ", " + perch + " ,'" + user.getEmail() + "');";
                } else {
                    type = 1;
                    Assistant tmp = (Assistant) user;
                    perch = tmp.getPersonalCost();
                    sql = "INSERT INTO User (Id,Name,Password,Type,PersonalCost,idInventory,email) " + "VALUES (" + user.getId() + ", '" + user.getName() + "', '" + user.getPassword() + "', " + type + ", " + perch + " ," + tmp.getInventory().getId() + " ,'" + user.getEmail() + "');";
                }

                stmt = c.createStatement();
                stmt.executeUpdate(sql);
                c.commit();
            } catch (Exception e) {
                System.err.println(e.getClass().getName() + ": " + e.getMessage());
            }
        }

        for (Customer customer : customers) {
            try {
                sql = "INSERT INTO Customer (id,BusinessName,Country,Email) " + "VALUES (" + customer.getId() + ", '" + customer.getBusinessName() + "', '" + customer.getCountry() + "', '" + customer.getEmail() + "');";
                stmt = c.createStatement();
                stmt.executeUpdate(sql);
                c.commit();
            } catch (Exception e) {
                System.err.println(e.getClass().getName() + ": " + e.getMessage());
            }
        }

        for (Operation operation : operations) {
            try {
                if (operation.getAssistant() != null)
                    sql = "INSERT INTO CustomerAssistant (idHead,idAssistant,IdCustomer,Total,PersonalCost) " + "VALUES (" + operation.getId() + ", '" + operation.getAssistant().getId() + "', " + operation.getCustomer().getId() + " ,'" + operation.getTotal() + "', '" + operation.getOPersonalCost() + "');";
                else
                    sql = "INSERT INTO CustomerAssistant (idHead,idAssistant,IdCustomer,Total,PersonalCost) " + "VALUES (" + operation.getId() + ", '" + -1 + "', " + operation.getCustomer().getId() + " ,'" + operation.getTotal() + "', '" + operation.getOPersonalCost() + "');";
                stmt = c.createStatement();
                stmt.executeUpdate(sql);
                c.commit();
            } catch (Exception e) {
                System.err.println(e.getClass().getName() + ": " + e.getMessage());
            }
            try {
                for (Pair<Article, Integer> i : operation.getRows()) {
                    sql = "INSERT INTO CustomerAssistantArticle (idHead,idArticle,qta) " + "VALUES (" + operation.getId() + ", " + i.getValue0().getId() + "," + i.getValue1() + ");";
                    stmt = c.createStatement();
                    stmt.executeUpdate(sql);
                    c.commit();
                }
            } catch (Exception e) {
                System.err.println(e.getClass().getName() + ": " + e.getMessage());
            }
        }

        for (Inventory inventory : inventories) {
            try {
                sql = "INSERT INTO InventoryUser (idHead,Description,MarketZone) " + "VALUES (" + inventory.getId() + ", '" + inventory.getDescription() + "', '" + inventory.getZone() + "');";
                stmt = c.createStatement();
                stmt.executeUpdate(sql);
                c.commit();
            } catch (Exception e) {
                System.err.println(e.getClass().getName() + ": " + e.getMessage());
            }
            try {
                for (Article article : inventory.getArticles()) {
                    sql = "INSERT INTO InventoryArticle (idHead,idArticle) " + "VALUES (" + inventory.getId() + ", " + article.getId() + ");";
                    stmt = c.createStatement();
                    stmt.executeUpdate(sql);
                    c.commit();
                }
            } catch (Exception e) {
                System.err.println(e.getClass().getName() + ": " + e.getMessage());
            }

        }

        for (Article article : articles) {
            if (article instanceof Compound) {
                Compound tmp = (Compound) article;
                for (Article a : tmp.getComponents()) {
                    try {
                        sql = "INSERT INTO ArticleCompound (IdCompound,IdComponent) " + "VALUES (" + article.getId() + ", " + a.getId() + ");";
                        stmt = c.createStatement();
                        stmt.executeUpdate(sql);
                        c.commit();
                    } catch (Exception e) {
                        System.err.println(e.getClass().getName() + ": " + e.getMessage());
                    }
                }
            }
            try {
                sql = "INSERT INTO Article (Id,Name,Price) " + "VALUES (" + article.getId() + ", '" + article.getName() + "', '" + article.getPrice() + "');";
                stmt = c.createStatement();
                stmt.executeUpdate(sql);
                c.commit();
            } catch (Exception e) {
                System.err.println(e.getClass().getName() + ": " + e.getMessage());
            }
        }

        for (String notify : notCenter.getNotification()) {
            try {
                sql = "INSERT INTO Notification (Message) " + "VALUES ('" + notify + "');";
                stmt = c.createStatement();
                stmt.executeUpdate(sql);
                c.commit();
            } catch (Exception e) {
                System.err.println(e.getClass().getName() + ": " + e.getMessage());
            }
        }

        try {
            stmt.close();
            c.close();
        } catch (Exception e2) {
            e2.printStackTrace();
        }

        instance = null;
    }
\end{lstlisting}

Il metodo \textit{Run()} rappresenta il loop del sistema. Instaura la connessione col Database tramite la DBConnection, chiede i dati per il login ed effettua il ciclo sulla variabile booleana \textit{WantClose()} da cui si chiama lo \textit{ShowMenu()}. Quando si desidera uscire dal programma questa variabile verr\'{a} messa a true interrompendo il loop.
\UseRawInputEncoding
\begin{lstlisting}[caption={Implementazione Run()},captionpos=b]
\end{lstlisting}

 

\section{UnitTest}
Prendiamo adesso in analisi la parte dei test effettuati per verificare la correttezza del codice. La base dati utilizzata \'{e} semplicemente una copia di quella usata nel programma principale. I test effettuati ricoprono la parte di creazione ed eliminazione di assistenti, inventari, articoli e clienti. La funzione \textit{prepare()} collega il database tramite la DBConnectionTest tramite la libreria Junit5.
\subsection{Assistant test}
Vediamo il funzionamento dei test per la classe \textit{Assistant}.
\subsubsection{Creazione/eliminazione di un'operazione}
Verifichiamo il corretto funzionamento di creazione di una operazione da parte di un assistente. Creiamo una lista di articoli con la loro relativa quantit\'{a} e viene creato anche un cliente test a cui assegnare tale operazione. Verifichiamo poi che l'ordine sia stato effettuato correttamente.
\UseRawInputEncoding
\begin{lstlisting}[caption={Implementazione creazione operazione},captionpos=b]
@Test
    @DisplayName("Create Operation Test")
    void testOperationCreation() {

        ArrayList<Pair<Article, Integer>> articles = new ArrayList<>();

        articles.add(new Pair<>(assistant.getInventory().getArticles().get(1), 20));
        articles.add(new Pair<>(assistant.getInventory().getArticles().get(2), 50));

        Customer customer = p.getCustomers().get(2);

        assistant.createOperation(customer, articles);

        Operation createdOperation = p.getOperations().get(p.getOperations().size() - 1);


        assertAll("Order's Data",
                () -> assertEquals(createdOperation.getAssistant(), assistant),
                () -> assertEquals(createdOperation.getCustomer(), customer),
                () -> assertEquals(createdOperation.getArticles().get(0), articles.get(0).getValue0()),
                () -> assertEquals(createdOperation.getArticles().get(1), articles.get(1).getValue0())
        );

    }
\end{lstlisting}
Analogamente adesso vogliamo che l'operazione appena creata venga rimossa dal database.
\UseRawInputEncoding
\begin{lstlisting}[caption={Implementazione eliminazione operazione},captionpos=b] @Test
    @DisplayName("Delete Operation Test")
    void testDeleteOperation() {

        Operation operation = p.getOperations().get(0);

        for (Operation i : p.getOperations()) {
            if (i.getAssistant() == assistant) {
                operation = i;
            }
        }

        int operationCountBefore1 = p.getOperations().size();

        assistant.deleteOperation(operation.getId());

        Operation finalOp = operation;
        assertAll("Operation deleted",
                () -> assertTrue(p.getOperations().size() < operationCountBefore1),
                () -> assertFalse(p.getOperations().contains(finalOp))
        );

    }

\end{lstlisting}
\subsection{Denstist test}
Controlliamo adesso il corretto funzionamento della classe dentista, ovvero il nostro amministratore.
\subsubsection{Creazione/eliminazione di un assistente}
Inseriamo manualmente un assistente e verifichiamo che effettivamente esista.
\UseRawInputEncoding
\begin{lstlisting}[caption={Implementazione creazione assistente},captionpos=b]
  @Test
    @DisplayName("Create AssistantTest")
    void testCreateAssistant() {

        Inventory inventory = p.getInventories().get( (int)((Math.random() * (p.getInventories().size()-1 - 1)) + 1) );
        admin.createAssistant("UnitTest", "studiomartino",5.5F,inventory,"unitTest@gmail.com");
        User createUser = p.getUsers().get(p.getUsers().size()-1);

        assertTrue(createUser instanceof Assistant);

        Assistant createAssistant = (Assistant) createUser;

        assertAll("Test create assistant",
                () -> assertEquals(inventory, createAssistant.getInventory()),
                () -> assertEquals(createAssistant.getId(), p.getUsers().get(p.getUsers().size()-1).getId())
        );

    }
\end{lstlisting}
Cancelliamo adesso un assistente e verifichiamo che non sia pi\'{u} presente. Abbiamo aggiunto un controllo che ci permette di controllare che all'eliminazione dell'assistente anche il suo inventario associato non sia stato cancellato.
\begin{lstlisting}[caption={Implementazione eliminazione assistente},captionpos=b]
 @Test
    @DisplayName("Delete AssistantTest")
    void testDeleteAssistant() {

        int id = 0;
        int id2 = 3;

        for (User u : p.getUsers()) {
            if (u.getId() == id) {
                admin.deleteAssistant(id);
            }
        }


        assertFalse(p.getUsers().contains(id));


    }

    private boolean checkInventory(int id){
        for (Inventory t : p.getInventories()){
            if(t.getId()==id){
                for (User u : p.getUsers()){
                    if(u instanceof Assistant){
                        if(((Assistant)u).getInventory().equals(t)){
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
\end{lstlisting}
\subsubsection{Creazione/eliminazione inventario}
Creiamo manualmente un inventario con relativi articoli e controlliamo che sia stato effettivamente inserito.
\begin{lstlisting}[caption={Implementazione creazione inventario},captionpos=b]
 @Test
    @DisplayName("Create InventoryTest")
    void testCreateInventory() {

        ArrayList<Article> articles = new ArrayList<>();
        articles.add(p.getArticles().get(1));
        articles.add(p.getArticles().get(2));
        articles.add(p.getArticles().get(3));
        int preSize = p.getInventories().size();
        admin.createInventory("description","Italy",articles);

        assertAll("Test create assistant",
                () -> assertEquals(preSize + 1, p.getInventories().size()),
                () -> assertEquals(articles, p.getInventories().get(p.getInventories().size()-1).getArticles())
        );

    }
\end{lstlisting}
Adesso lo eliminiamo e verifichiamo che non esista pi\'{u}.
\begin{lstlisting}[caption={Implementazione eliminazione inventario},captionpos=b]
@Test
    @DisplayName("Delete InventoryTest")
    void testDeleteInventory() {

        int preSize = p.getInventories().size();
        boolean check;

        ArrayList<Article> articles = new ArrayList<>();
        articles.add(p.getArticles().get(1));
        articles.add(p.getArticles().get(2));
        articles.add(p.getArticles().get(3));
        admin.createInventory("description","Italy",articles);
        preSize = p.getInventories().size();

        int lastCat = p.getInventories().get(p.getInventories().size()-1).getId();
        check = checkInventory(lastCat);

        admin.deleteInventory(lastCat);

        if(check)
            assertEquals(preSize - 1, p.getInventories().size());
        else
            assertEquals(preSize - 1, p.getInventories().size());

    }
\end{lstlisting}
\subsubsection{Creazione/Eliminazione di un prodotto}
Aggiungiamo adesso prima un semplice articolo e verifichiamo che sia stato inserito, poi creiamo un articolo di tipo composto e controlliamo che sia stato generato correttamente.
\begin{lstlisting}[caption={Implementazione creazione prodotti},captionpos=b]
 @Test
    @DisplayName("Create ProductTest")
    void testCreateProduct() {
        int preSize = p.getArticles().size();
        admin.createProduct("ProductTestSingle",3.5F);

        assertAll("Single Article",
                () -> assertEquals(preSize + 1, p.getArticles().size()),
                () -> assertTrue(p.getArticles().get(p.getArticles().size()-1) instanceof Product),
                () -> assertEquals(p.getArticles().get(p.getArticles().size()-1).getPrice(), 3.5F)
        );

        int preSize2 = p.getArticles().size();
        ArrayList<Article> articles = new ArrayList<>();
        articles.add(p.getArticles().get(1));
        articles.add(p.getArticles().get(2));

        float tmp = 0 ;
        for (Article a : articles)
            tmp += a.getPrice();
        float prePrice = tmp;

        admin.createProduct("Compound article",articles);

        assertAll("Compound Article",
                () -> assertEquals(preSize2 + 1, p.getArticles().size()),
                () -> assertTrue(p.getArticles().get(p.getArticles().size()-1) instanceof Compound),
                () -> assertEquals(p.getArticles().get(p.getArticles().size()-1).getPrice(), prePrice)

        );

    }
\end{lstlisting}
Analogamente eliminiamo i prodotti. Controlliamo inoltre che non possa cancellarsi un articolo che è presente in un articolo composto.
\begin{lstlisting}[caption={Implementazione eliminazione prodotti},captionpos=b]
 @Test
    @DisplayName("Delete ArticleTest")
    void testDeleteArticle() {

        admin.createProduct("testProduct1 - can_delete",5.5F);
        Article P1 = p.getArticles().get(p.getArticles().size()-1);
        int A1 = p.getArticles().get(p.getArticles().size()-1).getId();
        admin.deleteProduct(A1);

        assertFalse(p.getArticles().contains(P1));

        int A2 = 1;
        Article P2 = null;

        for(Article a : p.getArticles()){
            if(a.getId()==1) {
                P2 = a;
            }
        }
        admin.deleteProduct(A2);
        assertFalse(p.getArticles().contains(P2));

        ArrayList<Article> articles = new ArrayList<>();
        articles.add(p.getArticles().get(2));
        articles.add(p.getArticles().get(3));
        admin.createProduct("testProduct2", articles);
        Article P3 = p.getArticles().get(2);
        int A3 = p.getArticles().get(2).getId();
        admin.deleteProduct(A3);

        assertFalse(p.getArticles().contains(P3));

    }

\end{lstlisting}
\subsubsection{Eliminazione cliente}
Verifichiamo che possa essere correttamente rimosso un cliente dello studio.
\begin{lstlisting}[caption={Implementazione eliminazione cliente},captionpos=b]
@Test
    @DisplayName("Delete CustomerTest")
    void testDeleteCustomer() {

        Customer C1 = null;
        Customer C2 = null;

        for (Customer cli : p.getCustomers()){
            if(cli.getId() == 1)
                C1 = cli;
            if(cli.getId() == 2)
                C2 = cli;
        }

        admin.deleteCustomer(1);
        assertFalse(p.getCustomers().contains(C1));

    }
\end{lstlisting}

\subsection{CoreTest}
Controlliamo che le connessioni tra database si effettuino correttamente.
\subsubsection{Login test}
\begin{lstlisting}[caption={Implementazione login },captionpos=b]
 @Test
    @DisplayName("Login user Test")
    void testLoginUser() {

        p.login("Pampa", "studiomartino");

        User user = null;

        for (User i : p.getUsers()) {
            if (i.getName().equals("Pampa")) {
                user = i;
            }
        }

        User expectedUser1 = user;

        assertAll("Assistant Login",
                () -> assertEquals(expectedUser1, p.getActiveUser()),
                () -> assertTrue(p.getActiveUser() instanceof Assistant)
        );

        p.logout();

        p.login("Nicola", "ilmiostudio");

        user = null;

        for (User i : p.getUsers()) {
            if (i.getName().equals("Nicola")) {
                user = i;
            }
        }

        User expectedUser2 = user;

        assertAll("Dentist Login",
                () -> assertEquals(expectedUser2, p.getActiveUser()),
                () -> assertTrue(p.getActiveUser() instanceof Dentist)
        );
    }
\end{lstlisting}
\subsection{Test Load/Upload}
Controlliamo adesso che il collegamento tra database funzioni e che \textit{Upload} e \textit{Load} siano effettive. Si utilizzano delle query manuali dove inseriamo alcuni personaggi di Topolino come Test. Attraverso il metodo \textit{load} si verifica che i nuovi dati siano stati inseriti correttamente. Inseriamo poi alcuni articoli in modo che si possa chiamare il metodo 	\textit{upload(Connection)}
\begin{lstlisting}[caption={Implementazione Load/Upload },captionpos=b]
 @Test
    @DisplayName("Upload/Load data Test")
    void testUploadLoadData() throws SQLException {
        String sql;
        Statement stmt;
        ResultSet rs;

        Connection c = DBConnectionTest.getInstance();
        p.upload(c);
        p = Program.getInstance();

        c = DBConnectionTest.getInstance();

        String customerName = "Paperino";
        String customerCountry = "Paperinolandia";
        String customerEmail = "paperino.senzacognome@gmail.com";

        sql = "INSERT INTO Customer (BusinessName,Country,Email) " + "VALUES ('" + customerName + "', '" + customerCountry + "', '" + customerEmail + "');";

        stmt = c.createStatement();
        stmt.executeUpdate(sql);
        c.commit();

        String articleName = "Penny";
        float articlePrice = 10.2F;

        sql = "INSERT INTO Article (Name,Price) " + "VALUES ('" + articleName + "', '" + articlePrice + "');";
        stmt = c.createStatement();
        stmt.executeUpdate(sql);
        c.commit();

        p.load(c);

        Customer newCustomer = null;
        Article newArticle = null;

        for (Customer i : p.getCustomers()) {
            if (i.getBusinessName().equals(customerName) && i.getCountry().equals(customerCountry) && i.getEmail().equals(customerEmail)) {
                newCustomer = i;
            }
        }

        for (Article i : p.getArticles()) {
            if (i.getName().equals(articleName) && i.getPrice() == articlePrice) {
                newArticle = i;
            }
        }

        Customer finalNewCustomer = newCustomer;
        Article finalNewArticle = newArticle;
        assertAll("Load From DB",
                () -> assertNotNull(finalNewCustomer),
                () -> assertNotNull(finalNewArticle)
        );

        p.login("Nicola", "ilmiostudio");
        Dentist admin = (Dentist) p.getActiveUser();

        admin.createProduct("Berretto", 12.2F);
        admin.createCustomer("Minnie", "paperinolandiaSud", "minnie.senzacognome@gmail.com");

        p.upload(c);

        c = DBConnectionTest.getInstance();
        stmt = c.createStatement();

        int risArticle = 0;
        rs = stmt.executeQuery("SELECT COUNT(*) as ris FROM Article WHERE name='Berretto';");
        while (rs.next()) {
            risArticle = rs.getInt("ris");
        }

        int risCustomer = 0;
        rs = stmt.executeQuery("SELECT COUNT(*) as ris FROM Customer WHERE businessname='Minnie' AND country='paperinolandiaSud' AND email='minnie.senzacognome@gmail.com';");
        while (rs.next()) {
            risCustomer = rs.getInt("ris");
        }

        int finalRisArticle = risArticle;
        int finalRisCustomer = risCustomer;
        assertAll("Upload To DB",
                () -> assertTrue(finalRisArticle >= 1),
                () -> assertTrue(finalRisCustomer >= 1)
        );

        sql = "DELETE FROM Customer WHERE LOWER(businessname) LIKE '%test%';";
        stmt.executeUpdate(sql);
        c.commit();

        sql = "DELETE FROM Article WHERE LOWER(name) LIKE '%test%';";
        stmt.executeUpdate(sql);
        c.commit();
    }
\end{lstlisting}

\section{Conclusione}
Siamo partiti con questo progetto circa 1 anno prima della sua conclusione. Durante la sua stesura non avevamo molto chiaro cosa effettivamente fare ma durante questo tempo con ulteriore esperienza abbiamo trovato la via. Inizialmente pensavamo di fare una gestione di un magazzino ma successivamente il mio collega mi ha accennato al fatto che suo padre avesse uno studio dentistico e abbiamo deciso di adattare la struttura gi\'{a} esistente a questa situazione. Pensavamo di fare un interfaccia grafica affinch\'{e} si potesse navigare nel men\'{u}, adesso semplice console, in modo pi\'{u} 'attuale'. Tuttavia abbiamo dovuto ridimensionare il tutto in quanto ci avrebbe portato via molto tempo ulteriore.
\end{document}

\maketitle
\tableofcontents
